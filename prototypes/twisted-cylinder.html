<!doctype html>
<html>
  <head>
    <style>
      * {
        margin: 0;
        padding: 0;
      }
      canvas {
        display: block;
        position: absolute;
        top: 0;
        left: 0;
      }
    </style>
  </head>
  <body>
    <div class="scripts">
      <script src="../release/third-party/three.js"></script>
      <script src="../release/src/interaction.js"></script>
      <script>

        var renderer = new THREE.WebGLRenderer( { antialias: true } );
        var scene = new THREE.Scene();
        var camera = new THREE.PerspectiveCamera( 75 );

        var geometry = new THREE.TorusBufferGeometry( 100, 5, 4, 128 );
        geometry.rotateX( Math.PI / 2 );

        var ring = new THREE.Mesh(
          geometry,
          new THREE.ShaderMaterial( {

            // wireframe: true,

            uniforms: {
              twist: { type: 'f', value: 0 }, // In radians
              radius: { type: 'f', value: 100 },
              phi: { type: 'f', value: 5.0 },
              amplitude: { type: 'f', value: 10 }
            },

            vertexShader: [

              "const float PI = 3.141592653589793;",

              "uniform float twist;",
              "uniform float radius;",
              "uniform float phi;",
              "uniform float amplitude;",

              "varying vec2 vUv;",

              "void main() {",

                "vUv = uv;",

                "float theta = atan( position.z, position.x );",
                "vec3 spine = radius * vec3( cos( theta ), 0.0, sin( theta ) );",

                "float dp = dot( position, spine );",
                "float no = length( position ) * length( spine );",

                "float angle = acos( dp / no );",
                "float magnitude = distance( position, spine );",

                "float sa = sin( twist * PI );",
                "float ca = cos( twist * PI );",

                "mat3 rotation = mat3( 1.0 );",

                "rotation[ 0 ][ 0 ] = ca * rotation[ 0 ][ 0 ] + sa * rotation[ 0 ][ 1 ];",
                "rotation[ 1 ][ 0 ] = ca * rotation[ 1 ][ 0 ] + sa * rotation[ 1 ][ 1 ];",
                "rotation[ 2 ][ 0 ] = ca * rotation[ 2 ][ 0 ] + sa * rotation[ 2 ][ 1 ];",

                "rotation[ 0 ][ 1 ] = - sa * rotation[ 0 ][ 0 ] + ca * rotation[ 0 ][ 1 ];",
                "rotation[ 1 ][ 1 ] = - sa * rotation[ 1 ][ 0 ] + ca * rotation[ 1 ][ 1 ];",
                "rotation[ 2 ][ 1 ] = - sa * rotation[ 2 ][ 0 ] + ca * rotation[ 2 ][ 1 ];",

                "vec3 up = normalize( position - spine ) * rotation;",
                "vec3 pos = spine + up * magnitude;",

                // "pos.y += amplitude * sin( theta * phi );",

                "gl_Position = projectionMatrix * modelViewMatrix * vec4( pos, 1.0 );",

              "}"

            ].join( '\n' ),

            fragmentShader: [

              "varying vec2 vUv;",

              "void main() {",

                "gl_FragColor = vec4( vUv.x, 0.0, vUv.y, 1.0 );",

              "}"

            ].join( '\n' )

          } )
        );

        setup();

        function setup() {

          ring.rotation.x = - Math.PI / 2;
          ring.position.z = - 250;
          scene.add( ring );

          renderer.setClearColor( 0xefefef );

          document.body.appendChild( renderer.domElement );
          window.addEventListener( 'resize', resize, false );
          resize();
          renderer.setAnimationLoop( animate );

        }

        function resize() {

          var width = window.innerWidth;
          var height = window.innerHeight;

          renderer.setSize( width, height );

          camera.aspect = width / height;
          camera.updateProjectionMatrix();

        }

        function animate( time ) {


          // ring.rotation.x += 0.01;
          // ring.material.uniforms.amplitude.value = 10 * Math.sin( time / 500 );
          // ring.rotation.y += 0.01;
          ring.material.uniforms.twist.value += 0.01;
          renderer.render( scene, camera );

        }

      </script>
    </div>
  </body>
</html>
