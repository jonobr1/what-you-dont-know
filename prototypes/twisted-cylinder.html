<!doctype html>
<html>
  <head>
    <style>
      * {
        margin: 0;
        padding: 0;
      }
      canvas {
        display: block;
        position: absolute;
        top: 0;
        left: 0;
      }
    </style>
  </head>
  <body>
    <div class="scripts">
      <script src="../release/third-party/three.js"></script>
      <script src="../release/third-party/OrbitControls.js"></script>
      <script src="../release/src/interaction.js"></script>
      <script>

        var renderer = new THREE.WebGLRenderer( { antialias: true } );
        var scene = new THREE.Scene();
        var camera = new THREE.PerspectiveCamera( 75 );
        var controls = new THREE.OrbitControls( camera, renderer.domElement );

        var geometry = new THREE.CylinderBufferGeometry( 0.1, 0.1, 1, 4, 1024, true );
        geometry.rotateZ( - Math.PI / 2 );

        var ring = new THREE.Mesh(
          geometry,
          new THREE.ShaderMaterial( {

            // wireframe: true,

            uniforms: {
              twist: { type: 'f', value: 32 }, // In radians
              size: { type: 'f', value: 500 },
              thickness: { type: 'f', value: 1.5 },
              offset: { type: 'f', value: 0 }
            },

            vertexShader: [

              "const float PI = 3.141592653589793;",

              "uniform float twist;",
              "uniform float size;",
              "uniform float thickness;",
              "uniform float offset;",

              "varying vec2 vUv;",

              "float t;",
              "float index;",
              "float theta;",

              "float x;",
              "float y;",
              "float z;",

              "void main() {",

                "vUv = vec2( uv.y, ( position.y / 0.2 ) + 0.5 );",

                "t = vUv.x;",
                "theta = atan( position.y, position.z );",
                "index = mod( t + offset, 1.0 ) - 0.5;",
                "index = twist * abs( index );",

                "y = thickness * sin( theta + index ) * 0.1;",
                "z = thickness * cos( theta + index ) * 0.1 + 1.0;",

                "x = sin( t * PI * 2.0 ) * size * z;",
                "y *= size;",
                "z = cos( t * PI * 2.0 ) * size * z;",

                "vec3 pos = vec3( x, y, z );",

                "gl_Position = projectionMatrix * modelViewMatrix * vec4( pos, 1.0 );",

              "}"

            ].join( '\n' ),

            fragmentShader: [

              "varying vec2 vUv;",

              "void main() {",

                "gl_FragColor = vec4( pow( vUv.x, 2.0 ), 0.0, vUv.y, 1.0 );",

              "}"

            ].join( '\n' )

          } )
        );

        setup();

        function setup() {

          scene.add( ring );
          camera.far = 10000;
          camera.position.y = 500;
          camera.rotation.x = - Math.PI / 2;

          renderer.setClearColor( 0xefefef );

          document.body.appendChild( renderer.domElement );
          window.addEventListener( 'resize', resize, false );
          resize();
          renderer.setAnimationLoop( animate );

        }

        function resize() {

          var width = window.innerWidth;
          var height = window.innerHeight;

          renderer.setSize( width, height );

          camera.aspect = width / height;
          camera.updateProjectionMatrix();

        }

        function animate( time ) {


          // ring.material.uniforms.twist.value = 50 * ( Math.sin( time / 1000 ) + 1 ) / 2;
          // ring.material.uniforms.thickness.value = Math.sin( time / 500 ) + 1;
          ring.material.uniforms.offset.value -= 0.001;

          renderer.render( scene, camera );

        }

      </script>
    </div>
  </body>
</html>
