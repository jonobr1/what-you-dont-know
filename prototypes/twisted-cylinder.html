<!doctype html>
<html>
  <head>
    <style>
      * {
        margin: 0;
        padding: 0;
      }
      canvas {
        display: block;
        position: absolute;
        top: 0;
        left: 0;
      }
    </style>
  </head>
  <body>
    <div class="scripts">
      <script src="../release/third-party/three.js"></script>
      <script src="../release/third-party/OrbitControls.js"></script>
      <script src="../release/third-party/WebVR.js"></script>
      <script src="../release/src/interaction.js"></script>
      <script src="./js/dat.gui.min.js"></script>
      <script>

        var gui;

        var renderer = new THREE.WebGLRenderer( { antialias: true } );
        var scene = new THREE.Scene();
        var camera = new THREE.PerspectiveCamera( 75 );
        // var controls = new THREE.OrbitControls( camera, renderer.domElement );

        var geometry = new THREE.CylinderBufferGeometry( 0.1, 0.1, 1, 4, 512 );
        geometry.rotateZ( - Math.PI / 2 );

        var ring = new THREE.Mesh(
          geometry,
          new THREE.ShaderMaterial( {

            // wireframe: true,

            uniforms: {

              twist: { type: 'f', value: 0 }, // Applied to radians

              size: { type: 'f', value: 500 },
              thickness: { type: 'f', value: 1.5 },
              offset: { type: 'f', value: 0 },

              startAngle: { type: 'f', value: 0 },
              endAngle: { type: 'f', value: Math.PI * 2 },

              phi: { type: 'f', value: 8 },
              amplitude: { type: 'f', value: 0 }

            },

            vertexShader: [

              "const float PI = 3.141592653589793;",

              "uniform float twist;",

              "uniform float size;",
              "uniform float thickness;",
              "uniform float offset;",

              "uniform float startAngle;",
              "uniform float endAngle;",

              "uniform float phi;",
              "uniform float amplitude;",

              "varying vec2 vUv;",

              "float t;",
              "float angle;",
              "float index;",
              "float theta;",

              "float x;",
              "float y;",
              "float z;",

              "void main() {",

                "vUv = vec2( position.x + 0.5, ( position.y / 0.2 ) + 0.5 );",

                "t = vUv.x;",
                "angle = atan( position.y, position.z );",
                "index = mod( t + offset, 1.0 ) - 0.5;",
                "index = twist * abs( index );",

                "y = thickness * sin( angle + index ) * 0.1;",
                "z = thickness * cos( angle + index ) * 0.1 + 1.0;",

                "theta = t * ( endAngle - startAngle ) + startAngle;",

                "x = size * sin( theta ) * z;",
                "y = size * y + amplitude * sin( ( t + offset ) * PI * phi );",
                "z = size * cos( theta ) * z;",

                "vec3 pos = vec3( x, y, z );",

                "gl_Position = projectionMatrix * modelViewMatrix * vec4( pos, 1.0 );",

              "}"

            ].join( '\n' ),

            fragmentShader: [

              "varying vec2 vUv;",

              "void main() {",

                "gl_FragColor = vec4( pow( vUv.x, 2.0 ), 0.0, vUv.y, 1.0 );",

              "}"

            ].join( '\n' )

          } )
        );

        setup();

        function setup() {

          scene.add( ring );
          camera.far = 10000;

          ring.frustumCulled = false;

          // camera.position.y = 1000;
          // camera.rotation.x = - Math.PI / 2;

          renderer.setClearColor( 0xefefef );
          renderer.vr.enabled = true;

          document.body.appendChild( renderer.domElement );
          document.body.appendChild( WEBVR.createButton( renderer ) );

          window.addEventListener( 'resize', resize, false );
          resize();

          gui = new dat.GUI();
          for ( var name in ring.material.uniforms ) {

            var property = ring.material.uniforms[ name ];
            gui.add( property, 'value' ).name( name ).step( 0.1 );

          }

          renderer.setAnimationLoop( animate );

        }

        function resize() {

          var width = window.innerWidth;
          var height = window.innerHeight;

          renderer.setSize( width, height );

          camera.aspect = width / height;
          camera.updateProjectionMatrix();

        }

        function animate( time ) {

          renderer.render( scene, camera );

        }

      </script>
    </div>
  </body>
</html>
