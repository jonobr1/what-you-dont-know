<!doctype html>
<html>
  <head>
    <style>
      * {
        margin: 0;
        padding: 0;
      }
      canvas {
        display: block;
        position: absolute;
        top: 0;
        left: 0;
      }
    </style>
  </head>
  <body>
    <div class="scripts">
      <script src="../release/third-party/three.js"></script>
      <script src="../release/src/interaction.js"></script>
      <script>

        var renderer = new THREE.WebGLRenderer( { antialias: true } );
        var scene = new THREE.Scene();
        var camera = new THREE.PerspectiveCamera( 75 );

        var geometry = new THREE.CylinderBufferGeometry( 0.1, 0.1, 1, 3, 256, true );
        geometry.rotateZ( - Math.PI / 2 );

        var ring = new THREE.Mesh(
          geometry,
          new THREE.ShaderMaterial( {

            // wireframe: true,

            uniforms: {
              twist: { type: 'f', value: 0 }, // In radians
              length: { type: 'f', value: 1000 },
              radius: { type: 'f', value: 50 },
              fulcrum: { type: 'f', value: 0 }
            },

            vertexShader: [

              "const float PI = 3.141592653589793;",

              "uniform float twist;",
              "uniform float length;",
              "uniform float radius;",
              "uniform float fulcrum;",

              "varying vec2 vUv;",

              "float t;",
              "float index;",
              "float theta;",
              "float offset;",

              "float x;",
              "float y;",
              "float z;",

              "void main() {",

                "vUv = vec2( uv.y, ( position.y / 0.2 ) + 0.5 );",

                "t = vUv.x;",
                "theta = atan( position.y, position.z );",
                "index = mod( t + fulcrum, 1.0 );",
                // "offset = twist * ( abs( sin( index * PI ) ) );",
                "offset = twist * sin( index * PI );",

                "x = radius * cos( theta + offset );",
                "y = ( twist * radius * 0.2 + radius ) * sin( theta + offset );",

                "vec3 anchor = vec3( length * ( t - 0.5 ), y, x );",

                "theta = 2.0 * PI * t;",

                "x = length * 0.5 * cos( theta );",
                "y = radius * 2.0 * ( vUv.y - 0.5 );",
                "z = length * 0.5 * sin( theta );",

                "vec3 pos = vec3( x, y, z );",

                "gl_Position = projectionMatrix * modelViewMatrix * vec4( anchor, 1.0 );",

              "}"

            ].join( '\n' ),

            fragmentShader: [

              "varying vec2 vUv;",

              "void main() {",

                "gl_FragColor = vec4( pow( vUv.x, 2.0 ), 0.0, vUv.y, 1.0 );",

              "}"

            ].join( '\n' )

          } )
        );

        setup();

        function setup() {

          // ring.rotation.x = - Math.PI / 2;
          ring.position.z = - 500;
          scene.add( ring );

          renderer.setClearColor( 0xefefef );

          document.body.appendChild( renderer.domElement );
          window.addEventListener( 'resize', resize, false );
          resize();
          renderer.setAnimationLoop( animate );

        }

        function resize() {

          var width = window.innerWidth;
          var height = window.innerHeight;

          renderer.setSize( width, height );

          camera.aspect = width / height;
          camera.updateProjectionMatrix();

        }

        function animate( time ) {


          // ring.rotation.x += 0.1;
          // ring.material.uniforms.amplitude.value = 10 * Math.sin( time / 500 );
          // ring.rotation.y += 0.01;
          ring.material.uniforms.twist.value = 9 * ( Math.sin( time / 500 ) + 1 ) / 2;
          ring.material.uniforms.fulcrum.value += 0.01;
          renderer.render( scene, camera );

        }

      </script>
    </div>
  </body>
</html>
