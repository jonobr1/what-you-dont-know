<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <style>
      * { margin: 0; padding: 0; }
      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <div class="scripts">
      <script src="../release/third-party/three.js"></script>
      <script src="../release/third-party/OrbitControls.js"></script>
      <script>

        var renderer = new THREE.WebGLRenderer( { antialias: true } );
        var scene = new THREE.Scene();
        var camera = new THREE.PerspectiveCamera( 75 );
        var controls = new THREE.OrbitControls( camera, renderer.domElement );

        var sphere = new THREE.Mesh(
          new THREE.SphereBufferGeometry( 5, 64, 64 ),
          new THREE.ShaderMaterial( {
            uniforms: {
              time: { type: 'f', value: 0 }
            },
            vertexShader: [

              'const float PI = ' + Math.PI + ';',

              'uniform float time;',

              'varying vec3 vReflect;',
              'varying float vRim;',

              'vec3 getPosition( vec3 position ) {',

                'vec3 n = normalize( position );',

                'float qpi = PI * 0.25;',
                'float phi = PI * ( cos( qpi * n.x ) + sin( qpi * n.z ) );',

                'float osc = sin( time + phi );',
                'float radius = 0.5 * osc + 4.0;',
                'return radius * n;',

              '}',

              'vec3 getAdjacent( vec3 position, vec2 offset ) {',

                'float theta;',
                'float l = length( position );',

                'vec3 p1 = vec3( offset.xyx );',
                'theta = atan( position.z, position.x ) + PI * 0.5;',
                'p1.x = offset.x * cos( theta );',
                'p1.z = offset.x * sin( theta );',

                'vec3 p2 = vec3( offset.xxy );',
                'theta = atan( position.y, position.x ) + PI * 0.5;',
                'p2.x = offset.x * cos( theta );',
                'p2.y = offset.x * sin( theta );',

                'float fade = step( 0.9, abs( position.y / l ) );',
                'vec3 v = position + mix( p1, p2, fade );',

                'return getPosition( l * normalize( v ) );',

              '}',

              'vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {',
                'return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );',
              '}',

              'void main() {',

                'vec2 eps;',
                'vec3 pos = getPosition( position );',

                'eps = vec2( 0.1, 0.0 );',
                'vec3 top = getAdjacent( pos, eps );',
                'vec3 bottom = getAdjacent( pos, - eps );',

                'eps = vec2( 0.0, 0.1 );',
                'vec3 left = getAdjacent( pos, eps );',
                'vec3 right = getAdjacent( pos, - eps );',

                'vec3 fNor = cross( normalize( left - right ), normalize( top - bottom ) );',

                'vec3 objectNormal = vec3( fNor );',
                'vec4 worldPosition = modelMatrix * vec4( pos, 1.0 );',
                'vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );',

                'vec3 transformedNormal = normalMatrix * objectNormal;',
                'vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );',
                'vReflect = reflect( cameraToVertex, worldNormal );',
                'vRim = 1.0 - clamp( pow( dot( cameraToVertex, worldNormal ), 2.0 ), 0.0, 1.0 );',

                'gl_Position = projectionMatrix * modelViewMatrix * vec4( pos, 1.0 );',

              '}'

            ].join( '\n' ),
            fragmentShader: [

              'const float PI = ' + Math.PI + ';',

              'varying vec3 vReflect;',
              'varying float vRim;',

              'void main() {',

                'vec3 reflectVec = normalize( vReflect );',

                // - HALF_PI to HALF_PI
                'float reflection = asin( reflectVec.y ) / ( PI * 0.5 ) + 0.5;',
                'reflection = clamp( reflection, 0.0, 1.0 );',
                'vec4 envColor = vec4( vec3( reflection ).xyz, 1.0 );',

                'float rim = smoothstep( 0.75, 1.0, vRim );',
                'vec3 highlight = vec3( 1.0, 1.0, 1.0 );',

                'gl_FragColor = vec4( mix( envColor.xyz, highlight, rim ), 1.0 );',

              '}'

            ].join( '\n' ),
            transparent: true,
          } )
        );

        setup();

        function setup() {

          scene.add( sphere );
          camera.position.z = 10;

          document.body.appendChild( renderer.domElement );
          window.addEventListener( 'resize', resize, false );
          resize();
          renderer.setAnimationLoop( draw );

        }

        function resize() {

          var width = window.innerWidth;
          var height = window.innerHeight;

          renderer.setSize( width, height );
          camera.aspect = width / height;
          camera.updateProjectionMatrix();

        }

        function draw( time ) {

          controls.update();

          sphere.material.uniforms.time.value = time / 250;
          renderer.render( scene, camera );

        }

      </script>
    </div>
  </body>
</html>
