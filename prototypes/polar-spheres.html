<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <style>
      * { margin: 0; padding: 0; }
      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <div class="scripts">
      <script src="../release/third-party/three.js"></script>
      <script src="../release/third-party/OrbitControls.js"></script>
      <script>

        var renderer = new THREE.WebGLRenderer( { antialias: true } );
        var scene = new THREE.Scene();
        var camera = new THREE.PerspectiveCamera( 75 );
        var controls = new THREE.OrbitControls( camera, renderer.domElement );

        var sphere = new THREE.Mesh(
          new THREE.SphereBufferGeometry( 5, 512, 512 ),
          new THREE.ShaderMaterial( {
            uniforms: {
              time: { type: 'f', value: 0 }
            },
            vertexShader: [

              'const float PI = ' + Math.PI + ';',

              'uniform float time;',

              'varying vec3 vReflect;',
              'varying float vRim;',

              'vec3 getPosition( vec3 position ) {',

                'vec3 n = normalize( position );',

                'float qpi = PI * 0.25;',
                'float phi = PI * ( cos( qpi * n.x ) + sin( qpi * n.z ) );',

                // 'float qpi = PI * 0.5;',
                // 'float amp = 5.0 * sin( time / 10.0 ) + 5.0;',
                // 'float phi = amp * ( sin( PI * uv.y ) + cos( qpi * n.x ) + sin( qpi * n.z ) );',

                'float osc = sin( time + phi );',
                'float radius = 0.5 * osc + 4.0;',
                'return radius * n;',

              '}',

              'vec3 getAdjacent( vec3 position, vec3 offset ) {',

                'float l = length( position );',
                'vec3 n = normalize( position ) + offset;',

                'return getPosition( l * n );',

              '}',

              'vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {',
                'return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );',
              '}',

              'void main() {',

                'vec3 pos = getPosition( position );',
                // TODO: Change this to angle based somehow
                'vec3 eps = vec3( 0.1, 0.0, 0.0 );',
                'vec3 top = getAdjacent( pos, eps.xyy );',
                'vec3 bottom = getAdjacent( pos, - eps.xyy );',
                'vec3 left = getAdjacent( pos, eps.yyx );',
                'vec3 right = getAdjacent( pos, - eps.yyx );',
                'vec3 fNor = cross( normalize( left - right ), normalize( top - bottom ) );',

                'vec3 objectNormal = vec3( fNor );',
                'vec4 worldPosition = modelMatrix * vec4( pos, 1.0 );',
                'vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );',

                'vec3 transformedNormal = normalMatrix * objectNormal;',
                'vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );',
                'vReflect = reflect( cameraToVertex, worldNormal );',
                'vRim = 1.0 - clamp( pow( dot( cameraToVertex, worldNormal ), 2.0 ), 0.0, 1.0 );',

                'gl_Position = projectionMatrix * modelViewMatrix * vec4( pos, 1.0 );',

              '}'

            ].join( '\n' ),
            fragmentShader: [

              'const float PI = ' + Math.PI + ';',

              'varying vec3 vReflect;',
              'varying float vRim;',

              'void main() {',

                'vec3 reflectVec = normalize( vReflect );',
                'vec2 sampleUV;',

                // - HALF_PI to HALF_PI
                'sampleUV.y = asin( reflectVec.y ) / ( PI * 0.5 ) + 0.5;',

                'vec4 envColor = vec4( clamp( sampleUV.yyy, 0.0, 1.0 ), 1.0 );',

                'float rim = smoothstep( 0.5, 1.0, vRim );',
                // 'vec3 white = vec3( 1.0, 1.0, 1.0 );',

                // 'gl_FragColor = vec4( mix( envColor.xyz, vec3( 0.95 ), rim ), 1.0 );',
                'gl_FragColor = vec4( envColor.xyz, 1.0 );',

              '}'

            ].join( '\n' ),
            transparent: true
          } )
        );

        setup();

        function setup() {

          scene.add( sphere );
          camera.position.z = 10;

          document.body.appendChild( renderer.domElement );
          window.addEventListener( 'resize', resize, false );
          resize();
          renderer.setAnimationLoop( draw );

        }

        function resize() {

          var width = window.innerWidth;
          var height = window.innerHeight;

          renderer.setSize( width, height );
          camera.aspect = width / height;
          camera.updateProjectionMatrix();

        }

        function draw( time ) {

          controls.update();

          sphere.material.uniforms.time.value = time / 250;
          renderer.render( scene, camera );

        }

      </script>
    </div>
  </body>
</html>
